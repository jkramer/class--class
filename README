NAME
    Class::Class - Adds data members to Perl packages

SYNOPSIS
    In module MyModule.pm:

      package MyModule;
      use Class::Class;
      @ISA = qw (Class::Class);

      %MEMBERS =
        (scalar_ => '$', # "scalar" is a keyword
         scalarref => '\$',
         array => '@',
         arrayref => '\@',
         hash => '%',
         hashref => '\%',
         glob => '*',
         globref => '\*',
         object => 'Some::Package',
         objectref => '\Some::Package');

      sub initialize ($) {
        my ($self) = @_;

        # object initialization goes here: DO NOT USE 'new'

        return $self;
      }

      sub deinitialize ($) {
        my ($self) = @_;

        # object cleanup (if any) goes here: DO NOT USE 'DESTROY'

        return $self;
      }

    In other files which wish to use MyModule:

      use MyModule;

      my $mm = new MyModule;

      $mm->scalar_ (42); # set "scalar_" to 42
      $mm->scalar_ ( ); # get value of "scalar_"
      $mm->scalarref (1.1); # set "scalarref" to 1.1
      $mm->scalarref ( ); # get reference to value of "scalarref"

      $mm->array ( ); # get arrayref stored in "array"
      $mm->array (1); # get 2nd element of "array"
      $mm->array (1, 'fish'); # set 2nd element of "array" to 'fish'
      $mm->arrayref ( ); # get arrayref stored in "arrayref"
      $mm->arrayref (1); # get reference to 2nd element of "arrayref"
      $mm->arrayref (1, 'fish'); # set 2nd element of "arrayref" to 'fish'

      $mm->hash ( ); # get hashref stored in "hash"
      $mm->hash ('bob'); # get 'bob' element of "hash"
      $mm->hash ('bob', 'one'); # set 'bob' element of "hash" to 'one'
      $mm->hashref ( ); # get hashref stored in "hashref"
      $mm->hashref ('bob'); # get reference to 'bob' element of "hashref"
      $mm->hashref ('bob', 'one'); # set 'bob' element of "hashref" to 'one'

      open G, '<blah.txt';
      $mm->glob (*G); # set "glob" to *G
      $mm->glob ( ); # get value of "glob"
      use Symbol;
      $mm->globref (gensym); # set "globref" to anonymous symbol
      $mm->globref ( ); # get reference to value of "globref"

      $mm->object ( ); # get object in "object"
      $mm->object->method; # invoke method on object in "object"
      $mm->objectref ( ); # get reference to object in "objectref"

DESCRIPTION
    Class::Class implements inheritable data methods for your packages with
    the same rules of inheritance as your other methods by generating
    creating accessor methods for your data the first time you make an
    instance of your package.

    Why reinvent the wheel, you say? I got tired of the way Class::Struct
    worked, since the methods weren't inheritable the way I expected (no
    initialization of parent members before child members, for example), it
    was invoked programatically rather than declaratively, and I wanted to
    learn more about globs and the like. Plus I have a big head. :-)

  Using Class::Class Modules

    Using Class::Class modules is very simple. Just inherit from them as
    normal, but don't bother with writing a `new' method -- Class::Class
    provides one for you that arranges for superclasses to be initialized
    before subclasses. It also takes multiple inheritance into account
    (correctly, I hope).

    To initialize your package, instead of `sub new', write a `sub
    initialize' which takes an instance of your package as its only
    argument, and returns an instance:

      sub initialize ($) {
        my ($self) = @_;

        # Do something clever here with your object...

        return $self;
      }

    There is no requirement you return the same instance that was handed to
    you. The methods `polymorph' and `polyvolve' are provided for this very
    purpose, to help with "virtual constructors".

  Writing Class::Class Modules

    Writing Class::Class modules is straight-forward.

  Polymorph and Polyvolve

    `polymorph'
    `polyvolve'
EXAMPLES
  Using Class::Class Modules

    1. Simple use:
  Writing Class::Class Modules

    1. Setting a package global:
SEE ALSO
    the Class::ISA manpage

    Class::ISA creates an inverted inheritance tree, permitting easy
    traversal of a packages entire inheritance.

DIAGNOSTICS
    The following are the diagnostics generated by Class::Class. Items
    marked "(W)" are non-fatal (invoke `Carp::carp'); those marked "(F)" are
    fatal (invoke `Carp::croak').

    Not a class or subclass of '%s'
        (F) The caller tried to assign to an object data member something
        which isn't an instance of that object's class, or which isn't an
        instance of a derived class.

    No coderef defined for '%s' yet
        (F) The caller tried to use a code reference without first providing
        assigning a coderef to the member.

BUGS AND CAVEATS
    Presently, Class::Class uses hashes for data members; array are
    demonstrably better for several reasons (see XXX -- *TPJ*) if you don't
    need direct access to data members by name. And even if you do, fields
    shows a good way to do that with recent versions of Perl.

AUTHORS
    B. K. Oxley (binkley) at Home <binkley@bigfoot.com>

COPYRIGHT
      Copyright 1999, B. K. Oxley (binkley).

    This library is free software; you may redistribute it and/or modify it
    under the same terms as Perl itself.

